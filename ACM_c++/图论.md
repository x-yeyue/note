# 链式前向星

```c++
// 最大节点数
const int MAXN = 10 + 5;
// 最大边数
const int MAXM = 20 + 5;
int head[MAXN]; // idx:节点号   val:边的编号id
// 有向图
int nxt[MAXM]; // idx:边的编号id   val:下一条同起点边的编号
// 无向图
// int next[MAXM << 1]; 
int to[MAXM];   // idx:边的编号id   val:节点号
// int w[MAXM];    // idx:边的编号id   val:边的权重
int id = 1; // 边的编号
void add_edge(int _u, int _v){    // _u->_v
    nxt[id] = head[_u];
    to[id] = _v;
    head[_u] = id ++;
}
// void add_edge(int _u, int _v, int _w){ // _u->_v, weight = _w
//     nxt[id] = head[_u];
//     to[id] = _v;
//     w[id] = _w;
//     head[_u] = id ++;
// }

/*
// 遍历 u 的所有后继节点
for(int i = head[u]; i; i = nxt[i]){
    int v = to[i]; // u->v
    // int val = weight[i] // u->v的权重
}
*/

// memset(head, 0, sizeof(head));
```

# BFS  

> [lanqiaoOJ-迷宫](https://www.lanqiao.cn/problems/602/learning/)  

***简单方法***  
记录起点到终点的完整路径，适合小图。
```c++
# include <bits/stdc++.h>
using namespace std;
//#define int long long
#define ll long long
#define endl '\n'

const int n = 30, m = 50;
vector<vector<char> > mat;
vector<vector<bool> > vis;
vector<vector<int> > dirc = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};
vector<string> mp = {"D", "L", "R", "U"};
struct node{
    int x, y;
    string path;
    node() : x(-1), y(-1){}
    node(int _x, int _y, string _path = "") : x(_x), y(_y), path(_path){}
};

void bfs(){
    queue<node> que;
    que.emplace(node(0, 0));
    vis[0][0] = true;
    node cur, nxt;
    int nxt_x, nxt_y;
    while(!que.empty()){
        cur = que.front(); que.pop();
        if(cur.x == 29 && cur.y == 49){
            cout << cur.path;
            return;
        }
        for(int i = 0; i < 4; i ++){
            nxt_x = cur.x + dirc[i][0], nxt_y = cur.y + dirc[i][1];
            if(nxt_x < 0 || nxt_y < 0 || nxt_x >= 30 || nxt_y >= 50 || mat[nxt_x][nxt_y] == '1' || vis[nxt_x][nxt_y]) continue;
            nxt = node(nxt_x, nxt_y, (cur.path + mp[i]));
            vis[nxt.x][nxt.y] = true;
            que.emplace(nxt);
        }
    }
}

void solve(void){
    mat.resize(n, vector<char> (m));
    vis.resize(n, vector<bool> (m, false));
    for(int i = 0; i < n; i ++){
        for(int j = 0; j < m; j ++){
            cin >> mat[i][j];
        }
    }
    bfs();
}

signed main(void){
    ios::sync_with_stdio(0);
    //cin.tie(0); cout.tie(0);
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
```

## 双向广搜

>[跳蚱蜢](https://www.lanqiao.cn/problems/642/learning/?page=1&first_category_id=1&problem_id=642)


***单项广搜***
```c++
# include <bits/stdc++.h>
using namespace std;
//#define int long long
#define ll long long
#define endl '\n'

struct node{
    string s;
    int cnt;
    node() : s(""), cnt(0){}
    node(string _s, int _cnt) : s(_s), cnt(_cnt){}
};

string s = "012345678";
unordered_map<string, bool> mp;
queue<node> que;
void solve(void){
    que.emplace(node(s, 0));
    mp[s] = true;
    node cur, nxt;
    while(!que.empty()){
        cur = que.front(); que.pop();
        if(cur.s == "087654321"){
            cout << cur.cnt;
            return;
        }
        int inx;
        for(inx = 0; inx < 9; inx ++){
            if(cur.s[inx] == '0') break;
        }
        for(int j = inx - 2; j <= inx + 2; j ++){
            int k = (j + 9) % 9;
            if(k == inx) continue;
            node nxt = cur;
            swap(nxt.s[inx], nxt.s[k]);
            if(!mp[nxt.s]){
                mp[nxt.s] = true;
            }else{
                continue;
            }
            nxt.cnt ++;
            que.emplace(nxt);
        }
    }
}

signed main(void){
    ios::sync_with_stdio(0);
    //cin.tie(0); cout.tie(0);
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}

```

***双向广搜***

```c++
# include <bits/stdc++.h>
using namespace std;
//#define int long long
#define ll long long
#define endl '\n'

bool isok = false;
string s1 = "012345678", s2 = "087654321";
unordered_map<string, int> mp1, mp2;
queue<string> que1, que2;
void extend(queue<string>& que, unordered_map<string, int>& mp, unordered_map<string, int>& mp2){
    string cur, nxt;
    cur = que.front(); que.pop();
    int inx;
    for(inx = 0; inx < 9; inx ++){
        if(cur[inx] == '0') break;
    }
    for(int j = inx - 2; j <= inx + 2; j ++){
        int k = (j + 9) % 9;
        if(k == inx) continue;
        nxt = cur;
        swap(nxt[inx], nxt[k]);
        if(!mp[nxt]){
            mp[nxt] = mp[cur] + 1;
        }else{
            continue;
        }
        if(mp2[nxt]){
            cout << mp[nxt] + mp2[nxt];
            isok = true;
            return;
        }
        que.emplace(nxt);
    }
}

void dfs(){
    que1.emplace(s1); mp1[s1] = 0;
    que2.emplace(s2); mp2[s2] = 0;
    while(!que1.empty() && !que2.empty()){
        if(que1.size() <= que2.size()){
            extend(que1, mp1, mp2);
        }else{
            extend(que2, mp2, mp1);
        }
        if(isok){
            return;
        }
    }

}

void solve(){
    dfs();
}

signed main(void){
    ios::sync_with_stdio(0);
    //cin.tie(0); cout.tie(0);
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
```

---

# 最短路径问题

## Dijkstra

### 标准

> [蓝桥王国](https://www.lanqiao.cn/problems/1122/learning/?page=1&first_category_id=1&problem_id=1122)  

```c++
# include <bits/stdc++.h>
using namespace std;
//#define int long long
#define ll long long
#define endl '\n'
const ll INF = 0x3f3f3f3f3f3f3f3fLL;
const int N = 3e5 + 2;
struct edge{
    int from, to; // 起点、终点; 起点 from 没有用到，e[i] 的 i 就是 from
    ll w;   // 权值
    edge(int _from, int _to, ll _w): from(_from), to(_to), w(_w){}
};
struct node{
    int id; // 节点
    ll dis; // 节点到起点的距离
    node(int _id, ll _dis): id(_id), dis(_dis){}
    bool operator<(const node& a)const{
        return dis > a.dis;
    }
};
int n, m, s;
vector<int> pre(N, -1); // 记录前驱节点，用于生成路径
vector<vector<edge> > mat(N, vector<edge>{}); // 存图
vector<ll> dis(N, 0); // 记录所有节点到起点的距离；
void print_path(int s, int t){ // 输出从 s 到 t 的最短路径
    if(s == t){ // 输出起点
        cout << s << " ";
        return;
    }  
    print_path(s, pre[t]); // 输出前一个点
    cout << t << " "; // 后输出当前点。最后输出终点；
}
void dijkstra(){
    vector<bool> done(N, false); // true表示节点i的最短路径已经找到
    for(int i = 1; i <= n; i ++){ // init
        dis[i] = INF;
        done[i] = false;
    }
    dis[s] = 0; // 起点到自己的距离为0
    priority_queue<node> pq; // 存储节点信息
    pq.emplace(node(s, dis[s])); // 起点入队
    while(!pq.empty()){ 
        node cur = pq.top(); pq.pop(); // pop 出与起点 s 距离最小的节点 cur
        if(done[cur.id]) continue; // 丢弃已经找到最短路径的节点
        done[cur.id] = true;
        for(int i = 0; i < mat[cur.id].size(); i ++){ // 检查节点 cur 的所有邻居节点
            edge nxt = mat[cur.id][i]; // cur.id 的第 i 个邻居节点是 nxt.to
            if(done[nxt.to]) continue; // 丢弃已经找到最短路径的邻居节点
            if(dis[nxt.to] > nxt.w + cur.dis){
                dis[nxt.to] = nxt.w + cur.dis;
                pq.emplace(node(nxt.to, dis[nxt.to]));  // 扩展新的邻居节点，放到优先队列中
                pre[nxt.to] = cur.id;   // 如果有需要，就记录路径
            }
        }
    }
    //print_path(s, n); cout << endl; // 输出路径; 起点为 1，终点 n;
}

void solve(void){
    cin >> n >> m;
    s = 1; // 起点
    for(int i = 1; i <= n; i ++) mat[i].clear();
    while(m --){
        int a, b, w; cin >> a >> b >> w;
        mat[a].emplace_back(edge(a, b, w));
        // mat[b].emplace_back(edge(b, a, w)); // 双向
    }
    dijkstra();
    for(int i = 1; i <= n; i ++){
        if(dis[i] >= INF){
            cout << "-1 ";
        }else{
            cout << dis[i] << " ";
        }
    }
}

signed main(void){
    ios::sync_with_stdio(0);
    //cin.tie(0); cout.tie(0);
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
```

### 输出所有路径（加强版）

> **《城市间紧急救援》**
> 作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。
**输入格式:**
输入第一行给出 4 个正整数 n、m、s、d，其中 n（2≤n≤500）是城市的个数，顺便假设城市的编号为 0 ~ (n−1)；m 是快速道路的条数；s 是出发地的城市编号；d是目的地的城市编号。
第二行给出 n 个正整数，其中第 i 个数是第 i 个城市的救援队的数目，数字间以空格分隔。随后的 m 行中，每行给出一条快速道路的信息，分别是：城市 1、城市 2、快速道路的长度，中间用空格分开，数字均为整数且不超过 500。输入保证救援可行且最优解唯一。
**输出格式:**
第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从 s 到 d 的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。
**输入样例:**
4 5 0 3
20 30 40 10
0 1 1
1 3 2
0 3 3
0 2 2
2 3 2
**输出样例:**
2 60
0 1 3

```c++
#include <bits/stdc++.h>
using namespace std;
#define endl '\n';

struct node{
    int inx, dis;
    node():inx(-1), dis(INT_MAX){}
    node(int _inx, int _dis = INT_MAX):inx(_inx), dis(_dis){}
    bool operator<(const node nxt)const{
        return this->dis > nxt.dis;
    }
};
struct edge{
    int to, val;
    edge():to(-1), val(INT_MAX){}
    edge(int _to, int _val):to(_to), val(_val){}
};

int n, m, start, target;
priority_queue<node,vector<node> > pq;
vector<vector<edge> > mat;
vector<int> val; // 记录每个节点的救援队数量
vector<vector<int> > pre; // 记录前驱节点
vector<vector<int> > path; // 记录所有路径
vector<bool> done; // 记录是否找到最短距离
vector<int> dis; // 记录节点到起点的距离

void init(void){
    cin >> n >> m >> start >> target;
    mat.assign(n, vector<edge>{});
    val.assign(n, 0);
    pre.assign(n, vector<int>{});
    done.assign(n, false);
    dis.assign(n, INT_MAX); dis[start] = 0;
    
    for(auto& it : val) cin >> it;
    for(int i = 0; i < n; i ++){
        mat[i].reserve(500);
    }
    for(int i = 0; i < m; i ++){
        int a, b, v;
        cin >> a >> b >> v;
        mat[a].emplace_back(edge(b, v));
        mat[b].emplace_back(edge(a, v));
    }
    pq.emplace(node(start, 0));
}

void get_path(int cur, vector<int> temp_path){
    temp_path.emplace_back(cur);
    if(pre[cur].empty()){
        path.emplace_back(temp_path);
        return;
    }
    for(auto& it : pre[cur]){
        get_path(it, temp_path);
    }
}

struct cmp{
    bool operator()(const vector<int>& a, const vector<int>& b)const{
        int sum_a = 0, sum_b = 0;
        for(auto it : a){
            sum_a += val[it];
        }
        for(auto it : b){
            sum_b += val[it];
        }
        return sum_a > sum_b;
    }
};

void solve(void){
    init();
    while(!pq.empty()){
        node cur = pq.top(); pq.pop();
        if(done[cur.inx] && cur.inx == target) break;
        if(done[cur.inx]) continue;
        done[cur.inx] = true;
        for(auto& nxt : mat[cur.inx]){
            if(done[nxt.to]) continue;
            if(dis[nxt.to] > cur.dis + nxt.val){
                dis[nxt.to] = cur.dis + nxt.val;
                pre[nxt.to] = {cur.inx};
                pq.emplace(node(nxt.to, dis[nxt.to]));
            }else if(dis[nxt.to] == cur.dis + nxt.val){
                pre[nxt.to].emplace_back(cur.inx);
            }
        }
    }
    get_path(target, vector<int>{});
    sort(path.begin(), path.end(), cmp()); 
    int sums = 0;
    for(auto it : path.front()){
        sums += val[it];
    }
    cout << path.size() << " " << sums << endl;
    for(int i = path.front().size() - 1; i >= 0; i --){
        if(i == 0){
            cout << path.front()[i];
            continue;
        }
        cout << path.front()[i] << " ";
    }

    
}

signed main(void){
    ios::sync_with_stdio(false);
    solve();
    return 0;
}
```

## Floyd

```c++
const int INF = 0x13131313;

void solve(void){
    int n, m; // n 个节点，m 条边
    cin >> n >> m;
    vector<vector<int> > mat(n + 1, vector<int> (m, INF));  // 图
    vector<vector<int> > path(n + 1, vector<int> (m, -1));  // 路径
    for(int i = 0; i < m; i ++){
        int u, v, w; cin >> u >> v >> w;
        mat[u][v] = w;
        path[u][v] = u;
    }
    vector<vector<int> > dis(mat.begin(), mat.end());   // 最短路径
    
    for(int k = 1; k <= n; k ++){   // 中间节点
        for(int i = 1; i <= n; i ++){   // 左端节点
            for(int j = 1; j <= n; j ++){   // 右端节点
                if(dis[i][k] + dis[k][j] < dis[i][j]){
                    dis[i][j] = dis[i][k] + dis[k][j];
                    path[i][j] = path[k][j];
                }
            }
        }
    }
    
}
```

---

# 并查集

## template

```c++
int n, m; 
vector<int> arr;

void init(){
    for(int i = 0; i <= n; i ++) arr[i] = i;
}
int getFa(int a){ 
    if(a == arr[a]) return a; // 如果该节点指向自己
    //return getFa(arr[a]);
    return arr[a] = getFa(arr[a]);// 建森林
}
void Union(int x, int y){
    int X = getFa(x), Y = getFa(y); // 获取父节点
    if(X == Y) return; // 两节点在同一集合中
    arr[X] = Y; // 将两节点进行连接
}

void solve(){
    cin >> n >> m;
    arr.resize(n + 1);
    init();
    int a, b;
    for(int _ = 0; _ < m; _ ++){
        cin >> a >> b;
        Union(a, b);
    }
    //······

}
```

---

# 最小生成树（MST）

> 最小生成树(Minimum Spanning Tree, 简称 $MST$ )，是指在一个连通的无向图中，包含图中所有顶点的一颗树，且该树的所有边的权重之和最小。

## 性质

- **连通性**：最小生成树必定包含图中所有顶点，并且通过边将它们连接起来，确保整个图是连通的，即任意两个两点之间都有唯一一条路径。
- **无环**：最小生成树是一颗树，所以不能包含任何环。（一颗有 $n$ 个顶点的图中有且仅有 $n - 1$ 条边）
- **最小权重**：最小生成树的所有边的权重之和为所有生成树中最小。
- **最小生成树不唯一**：可能存在多个生成树为最小生成树，但最小生成树的权重和唯一。

## Prim(普利姆)算法

### 朴素 Prim 算法

>时间复杂度 $O(n^2)$

#### 算法步骤

1. 选择一个起始节点作为最小生成树的起点。
2. 将该起点节点加入最小生成树集合，并将其标记为已访问。
3. 在所有与最小生成树集合相邻的边中，选择和它连接的权重最小的边。
4. 将该边和所连节点加入最小生成树集合，并将该节点标记为已访问。
5. 重复步骤3和步骤4，直到最小生成树包含了图中的所有节点。

#### 代码实现

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 510;
int g[N][N], dist[N];   // 邻接矩阵，节点到生成树的连通部分的最短距离
bool st[N]; // 是否已经连通
int n, m;   // n 个节点, m 条边


int Prim(){
    int res = 0;    // 最小生成树的权重
    memset(dist, 0x3f3f3f3f, sizeof dist); // 初始化所有节点到连通部分的距离为无穷大
    dist[1] = 0;    // 从节点 1 开始
    
    for(int i = 0; i < n; i ++){    // 遍历所有节点
        int t = -1;
        // 找到还未加入集合的节点中距离最小的节点
        for(int j = 1; j <= n; j ++){
            if(!st[j] && (t == -1 || dist[t] > dist[j])) t = j;
        }    
        st[t] = true;   // 标记该节点已并入连通块
        // 该节点不可到达，图非连通
        if(dist[t] == 0x3f3f3f3f) return 0x3f3f3f3f;
        res += dist[t]; // 将当前节点的距离累加到结果中
        // 更新其他节点到集合的最小距离
        for(int j = 1; j <= n; j ++){
            dist[j] = min(dist[j], g[t][j]);
        }
    }
    return res;
}

void solve(void){
    memset(g, 0x3f3f3f3f, sizeof g); // 初始化所有边的权值为无穷大
    cin >> n >> m;
    for(int i = 0; i < m; i ++){
        int u, v, w;
        cin >> u >> v >> w;
        g[u][v] = g[v][u] = min(g[u][v], w); // 更新边权
    }
    int t = Prim();
    if(t == 0x3f3f3f3f){ // 图非连通，最小生成树不存在
        cout << "None" << endl;
        return;
    }
    cout << t << endl;
}


signed main(void){
    int t = 1;
    // cin >> t;
    while(t --){
        solve();
    }

    return 0;
}
```


### 堆优化 Prim 算法

> 时间复杂度：$O(mlogn)$

#### 算法步骤

1. 初始化 $dist$ 数组为 $INF$ ,表示所有节点到集合的距离为无穷大。
2. 创建一个小根堆，堆中的元素为( $dist$ 值，节点编号)。
3. 堆中点插入 $(0, 1)$ 表示节点 1 进入结合，$dist$ 值为 $0$。
4. 每次从堆中取出 $dist$ 值最小的元素 $(d, u)$，将 $u$ 加入集合。
5. 对 $u$ 相邻的所有节点 $v$ ，更新 $dist[v] = min(dist[v], g[u][v])$，并更新堆中的相应元素。
6. 重复步骤4和步骤5，直到所有节点都加入集合。
7. 最后根据取出的 $dist$ 值之和求出最小生成树的权重。

#### 代码实现

```c++
#include <bits/stdc++.h>
using namespace std;
#define pii pair<int, int>

const int N = 510, M = 1e5 + 10;
bool st[N]; // 标记节点是否已经加入最小生成树
int n, m, dist[N]; // dist数组用于记录每个节点到最小生成树的距离
int h[N], e[M], ne[M], idx, w[M]; // 邻接表存储图的边信息

void add(int a, int b, int c)
{
    e[idx] = b; // 存储边的另一个节点
    w[idx] = c; // 存储边的权值
    ne[idx] = h[a]; // 将边插入到节点a的邻接表头部
    h[a] = idx++; // 更新节点a的邻接表头指针
}

int Prim(){
    int res = 0, cnt = 0; // res用于记录最小生成树的权值和，cnt用于记录已经选择的边数
    priority_queue<pii, vector<pii>, greater<pii>> heap; // 最小堆，用于选择最短边
    memset(dist, 0x3f, sizeof dist); // 初始化dist数组为无穷大
    heap.push({ 0, 1 }); // 将节点1加入最小堆，距离为0
    dist[1] = 0; // 节点1到最小生成树的距离为0

    while (heap.size())
    {
        auto t = heap.top(); // 取出最小堆中距离最小的节点
        heap.pop();
        int ver = t.second, destination = t.first; // ver为节点，destination为距离
        if (st[ver]) continue; // 如果节点已经在最小生成树中，跳过
        st[ver] = true; // 将节点标记为已经加入最小生成树
        res += destination; // 更新最小生成树的权值和
        cnt++; // 增加已选择的边数

        // 遍历节点ver的所有邻接边
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            auto u = e[i]; // 邻接边的另一个节点
            if (dist[u] > w[i])
            {
                dist[u] = w[i]; // 更新节点u到最小生成树的距离
                heap.push({ dist[u], u }); // 将节点u加入最小堆
            }
        }
    }

    // 如果最小生成树的边数小于n-1，则图不连通，返回0x3f3f3f3f表示不可达
    if (cnt < n) return 0x3f3f3f3f;

    return res; // 返回最小生成树的权值和
}

void solve(void){
    memset(h, -1, sizeof h); // 初始化邻接表头指针为-1
    cin >> n >> m; // 输入节点数和边数

    for (int i = 0; i < m; ++i)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c), add(b, a, c); // 添加无向图的边到邻接表中
    }

    int t = Prim(); // 计算最小生成树的权值和
    if(t == 0x3f3f3f3f){ // 图非连通，最小生成树不存在
        cout << "None" << endl;
        return;
    }
    cout << t << endl;
}


signed main(void){
    int t = 1;
    // cin >> t;
    while(t --){
        solve();
    }

    return 0;
}
```

## Kruskal(克鲁斯卡尔)算法

> 时间复杂度: $O(mlogm)$

### 算法步骤

1. 创建一个空的最小生成树 $tree$。
2. 将图中所有边按照权重从小到大排序。
3. 从权重最小的边开始，判断其连接的连个节点是否在 $tree$ 中，若不在则加入。
4. 重复步骤 $3$ 直到所有点都包含在 $tree$ 中。

### 代码实现

```c++
struct edge{
    int a, b, val;  // a 节点，b 节点， 边的权重
    edge():a(0), b(0), val(0){}
    edge(int _a, int _b, int _val): a(_a), b(_b), val(_val){}
    bool operator<(const edge &nxt)const{
        return val < nxt.val;
    }
};

int n, m;   // 节点数，边数
vector<edge> Edge;  // 边集
vector<int> tree;    // 并查集，最小生成树 MST

void init(){
    cin >> n >> m;
    Edge.resize(m);
    tree.resize(n + 1, 0);
    for(int i = 0; i < m; i ++){    // 初始化边
        cin >> Edge[i].a >> Edge[i].b >> Edge[i].val;
    }
    for(int i = 1; i <= n; i ++){   // 初始化并查集
        tree[i] = i;
    }
}

int getFa(int x){   // 获得其父亲节点(建森林，路径压缩)
    if(tree[x] == x) return x;
    return tree[x] = getFa(tree[x]);
}

void Union(int x, int y){ // 将连个节点连接
    int X = getFa(x), Y = getFa(y);
    if(X == Y) return;
    tree[X] = Y;
}

int kruskal(){
    sort(Edge.begin(), Edge.end());
    int res = 0;    // 最小生成树的权重
    int cnt = 0;    // 已连接边数
    for(edge &it : Edge){
        int A = getFa(it.a);
        int B = getFa(it.b);
        if(A == B) continue; // 两个节点在同一个连通分量中
        cnt ++;
        res += it.val;
        Union(it.a, it.b);
    }
    if(cnt < n - 1){ // 无法构成最小生成树
        return INT_MAX;
    }
    return res;
}

void solve(){
    init();
    int res = kruskal();
    if(res == INT_MAX){
        cout << "None" << endl;
        return;
    }
    cout << res << endl;
}
```

# 二叉树

## 中序遍历与后序遍历构造二叉树

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    int inx; // 当前为后序遍历的索引位置
    unordered_map<int, int> mp; // 中序遍历每个元素的索引
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        inx = postorder.size() - 1; // 初始化后序遍历的索引
        for(int i = 0; i <= inx; i ++){ // 初始化mp0
            mp[inorder[i]] = i;
        }
        return solve(0, inx, inorder, postorder);
    }
    TreeNode* solve(int lf, int rt, vector<int>& inorder, vector<int>& postorder){
        if(lf > rt) return nullptr; // 叶子节点的子节点为空
        int flag = postorder[inx --]; // 当前的根节点
        TreeNode* root = new TreeNode(flag); // 构建根节点
        int mid = mp[flag]; 
        root->right = solve(mid + 1, rt, inorder, postorder); // 根节点的右节点
        root->left = solve(lf, mid - 1, inorder, postorder); // 根节点的左节点
        return root; // 返回根节点
    }
};
```

## 根据二叉搜索树的前序遍历，输出后序遍历

```c++
# include <bits/stdc++.h>
using namespace std;

int n, inx = 0; // 节点数， 后序遍历目前的索引位置
vector<int> pre; // 前序遍历
vector<int> suf; // 后序遍历
bool is_mirrow, is_tree = true; // 是否是镜像， 是否是二叉搜索树

void build(int lf, int rt){
    if(!is_tree || lf > rt) return;  // 不是二叉搜索树， lf > rt
    if(lf == rt){ // 叶子结点
        suf[inx ++] = pre[lf]; // 添加到后序数组
        return;
    }
    int root = pre[lf]; // 根节点
    int i = lf; // 寻找左右子树的分界点
    bool lf_true, rt_true;
    for(i = lf; i <= rt; i ++){
        lf_true = true, rt_true = true; // 确定左右子树是否正确
        for(int j = lf + 1; j <= i; j ++){ // 检查左子树
            if(is_mirrow ? pre[j] < root : pre[j] >= root){
                lf_true = false;
                break;
            }
        }
        for(int j = i + 1; j <= rt; j ++){ // 检查右子树
            if(is_mirrow ? pre[j] >= root : pre[j] < root){
                rt_true = false;
                break;
            }
        }
        if(lf_true && rt_true) break; // 找到了合法的分界点
    }
    if(!lf_true || !rt_true){ // 没有找到合法分界点
        is_tree = false;
        return;
    }
    build(lf + 1, i); // 递归处理左子树
    build(i + 1, rt); // 递归处理右子树
    suf[inx ++] = root; // 根节点放入后序数组
}

void init(){
    cin >> n;
    pre.resize(n, 0);
    suf.resize(n, 0);
    for(auto& it : pre) cin >> it;
    if(n > 1) is_mirrow = pre[0] <= pre[1];
}


void solve(){
    init();
    if(n == 1){
        cout << "YES" << endl;
        cout << pre.front();
        return;
    }
    build(0, n - 1);
    cout << (is_tree ? "YES" : "NO") << endl;
    if(is_tree){
        for(int i = 0; i < n; i ++){
            if(i == 0){
                cout << suf[i];
                continue;
            }
            cout << " " << suf[i];
        }
    }

}

signed main(void){
    solve();

    return 0;
}
```