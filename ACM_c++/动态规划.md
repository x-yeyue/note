# 一维动态规划

## 题目

### [最低票价](https://leetcode.cn/problems/minimum-cost-for-tickets/description/ "最低票价")

暴力解决
```c++
int n; // days.size()
vector<int> need = {1, 7, 30}; // 3 种票对应可免的天数

// 暴力获取
int dfs(vector<int> &days, vector<int> &costs, int cur){
    if(cur >= n) return 0; // 越界
    // 从下标 cur 开始，最少的花费是多少
    int ans = INT_MAX;
    for(int i = 0, j = cur; i < 3; i ++){
        // 购买索引为 i 的票
        // 下一次需要买票所在天的索引 
        while(j < n && days[cur] + need[i] > days[j]){
            j ++;
        }
        // 取最小
        ans = min(ans, costs[i] + dfs(days, costs, j));
    }
    return ans;
}

int mincostTickets(vector<int> &days, vector<int> &costs) {
    return dfs(days, costs, 0);
}

void solve(void){
    vector<int> days = {1,4,6,7,8,20};
    vector<int> costs = {2, 7, 15};
    n = days.size();
    cout << mincostTickets(days, costs) << endl;
}
```

记忆化搜索

```c++
int n; // days.size()
vector<int> need = {1, 7, 30}; // 3 种票对应可免的天数

// 暴力获取
int dfs(vector<int> &days, vector<int> &costs, int cur, vector<int> &dp){
    if(cur >= n) return 0; // 越界
    if(dp[cur] != INT_MAX) return dp[cur]; // 搜索过就返回
    // 从下标 cur 开始，最少的花费是多少
    int ans = INT_MAX;
    for(int i = 0, j = cur; i < 3; i ++){
        // 购买索引为 i 的票
        // 下一次需要买票所在天的索引 
        while(j < n && days[cur] + need[i] > days[j]){
            j ++;
        }
        // 取最小
        ans = min(ans, costs[i] + dfs(days, costs, j, dp));
    }
    return dp[cur] = ans; // 记忆化
}

int mincostTickets(vector<int> &days, vector<int> &costs) {
    vector<int> dp(n + 1, INT_MAX);
    return dfs(days, costs, 0, dp);
}

void solve(void){
    vector<int> days = {1,4,6,7,8,20};
    vector<int> costs = {2, 7, 15};
    n = days.size();
    cout << mincostTickets(days, costs) << endl;
}
```

# 最长递增子序列问题

> 给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

## 暴力

**时间复杂度**: $O(n^2)$

```c++
int lengthOfLIS(vector<int>& nums) { 
	int n = nums.size(); 
	vector<int> dp(n, 1); 
	int ans = 1; 
	for(int i = 1; i < n; i ++){ 
		for(int j = 0; j < i; j ++){ 
			if(nums[j] < nums[i]) dp[i] = max(dp[i], dp[j] + 1); 
		} 
		ans = max(ans, dp[i]); 
	} return ans; 
}
```

## 二分优化

**时间复杂度**: $O(n\log n)$

```c++
int lengthOfLIS(vector<int>& nums) {
	int n = nums.size();
	// 长度为 i + 1 的递增子序列的最小结尾
	vector<int> ends(n, -1);
	int len = 0;
	for(int i = 0; i < n; i ++){
		int inx = lower_bound(ends.begin(), ends.begin() + len, nums[i]) - ends.begin();
		if(inx == len){
			ends[len ++] = nums[i];
		}else{
			ends[inx] = nums[i]; 
		}
	}
	return len;        
}
```

# 背包问题

## 01背包

`t`: 表示背包的容量。
`n`: 货物数量，每个货物可选择 1 次。
`costs[i]`: 第`i`个货物的体积。
`values[i]`: 第`i`个货物的价值。

```c++
void solve(){
	int t, n;
	// cin>> t >> n;
	vector<int> costs(n), values(n);
	for(int i = 0; i < n; i ++) cin >> costs[i];
	for(int i = 0; i < n; i ++) cin >> values[i];
	// dp[i][j] := 考虑前 i 个物品，在容量为 j 的时候能拿的最大价值。
	vector<vector<int> > dp(n + 1, vector<int> (t + 1, 0));
	for(int i = 1; i <= n; i ++){
		for(int j = 0; j <= t; j ++){
			dp[i][j] = dp[i - 1][j];
			if(costs[i - 1] <= j) dp[i][j] = max(dp[i][j], dp[i - 1][j - costs[i - 1]] + values[i - 1]);
		}
	}
	cout << dp[n][t] << endl;
}
// 空间压缩
void solve(){
	int t, n;
	// cin>> t >> n;
	vector<int> costs(n), values(n);
	for(int i = 0; i < n; i ++) cin >> costs[i];
	for(int i = 0; i < n; i ++) cin >> values[i];
	// dp[i] := 容量为 i 的背包，能拿的最大价值  
    vector<int> dp(t + 1, 0);
    for(int i = 0; i < n; i ++){
        for(int j = t; j >= costs[i]; j --){
            dp[j] = max(dp[j], dp[j - costs[i]] + values[i]);
        }
    }
    cout << dp[t] << endl;
}
```