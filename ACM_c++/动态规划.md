# 一维动态规划

## 题目

### [最低票价](https://leetcode.cn/problems/minimum-cost-for-tickets/description/ "最低票价")

暴力解决
```c++
int n; // days.size()
vector<int> need = {1, 7, 30}; // 3 种票对应可免的天数

// 暴力获取
int dfs(vector<int> &days, vector<int> &costs, int cur){
    if(cur >= n) return 0; // 越界
    // 从下标 cur 开始，最少的花费是多少
    int ans = INT_MAX;
    for(int i = 0, j = cur; i < 3; i ++){
        // 购买索引为 i 的票
        // 下一次需要买票所在天的索引 
        while(j < n && days[cur] + need[i] > days[j]){
            j ++;
        }
        // 取最小
        ans = min(ans, costs[i] + dfs(days, costs, j));
    }
    return ans;
}

int mincostTickets(vector<int> &days, vector<int> &costs) {
    return dfs(days, costs, 0);
}

void solve(void){
    vector<int> days = {1,4,6,7,8,20};
    vector<int> costs = {2, 7, 15};
    n = days.size();
    cout << mincostTickets(days, costs) << endl;
}
```

记忆化搜索

```c++
int n; // days.size()
vector<int> need = {1, 7, 30}; // 3 种票对应可免的天数

// 暴力获取
int dfs(vector<int> &days, vector<int> &costs, int cur, vector<int> &dp){
    if(cur >= n) return 0; // 越界
    if(dp[cur] != INT_MAX) return dp[cur]; // 搜索过就返回
    // 从下标 cur 开始，最少的花费是多少
    int ans = INT_MAX;
    for(int i = 0, j = cur; i < 3; i ++){
        // 购买索引为 i 的票
        // 下一次需要买票所在天的索引 
        while(j < n && days[cur] + need[i] > days[j]){
            j ++;
        }
        // 取最小
        ans = min(ans, costs[i] + dfs(days, costs, j, dp));
    }
    return dp[cur] = ans; // 记忆化
}

int mincostTickets(vector<int> &days, vector<int> &costs) {
    vector<int> dp(n + 1, INT_MAX);
    return dfs(days, costs, 0, dp);
}

void solve(void){
    vector<int> days = {1,4,6,7,8,20};
    vector<int> costs = {2, 7, 15};
    n = days.size();
    cout << mincostTickets(days, costs) << endl;
}
```
