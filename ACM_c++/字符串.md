# 字符串哈希

## 性质

- 输入参数的可能性无线，输出的值范围相对有限
- 输入相同样本得到相同的值（没有随机机制）
- 输入不同的样本也可能得到相同的值（哈希碰撞，可能行较小）
- 输入大量不同的样本，得到大量输出值，几乎均匀的分布在整个输出域上

## 细节

1. 理解unsigned long long类型自然溢出，计算加减乘除时，自然溢出后的状态等同于对2^64次方取模的值。
2. 字符串化成base进制的数字并让其自然溢出。
3. base可以选择一些指数比如：433、299、599、1000000007；（经典值：31、131、1313、13131、131313等）
4. 转化时让每一位的值***从1开始***，不从0开始；
5. 利用数字的比较去替代字符串比较，可以大大减少复杂度  
>注：出现哈希碰撞就换base。

## template

```c++
#define ull unsigned long long
const int N = 1e6 + 10;
ull p[N], h[N]; // p[i] = P^i, h[i] = s[1~i]的hash值
string s;
// s = " " + s; // s 从1开始计算

void init(int n){
    p[0] = 1, h[0] = 0;
    for(int i = 1; i <= n; i ++){
        p[i] = p[i - 1] * P;
        h[i] = h[i - 1] * P + s[i];
    }
}
ull get(int lf, int rt){ // 计算s[lf~rt]的hash值
    return h[rt] - h[lf - 1] * p[rt - lf + 1];
}

```

# 字符串处理

## 常用函数

### find

- **str.find(s)**
    返回str中第一次出现s子串的位置。
- **str.find(s, pos)**
    返回str中从pos位置开始，第一次出现s子串的位置。
注：没有找到则返回 std::string::npos (-1).

### replace

- **str.replace(pos, len, s)**
    从 pos 位置开始将 len 长度的字符替换为 s.

### substr

- **str.substr(pos, len)**
    返回 str 从 pos 开始长度为 len 的子串。

### insert

- **str.insert(pos, s)**
    在 str 中 pos 位置添加子串 s.

## 字符串的操纵（字符串流）

> **流：** 流是一种抽象的概念，代表数据的来源和目的地。流可以是文件、控制台、内存中的字符串等。通过流，我们可以进行数据的输入（读取）和输出（写入）操作。标准 IO 库提供了一系列的流类，如 iostream、fstream 等，用于处理不同类型的流。

### 字符串流的定义

字符串流是一种特殊的流，它以字符串作为数据的来源或目的地。  
C++ 标准 IO 库提供了三个主要的字符串流类：
- **istringstream**：用于从字符串中读取数据，类似于从文件或控制台读取数据。
- **ostringstream**：用于将数据写入字符串，类似于将数据写入文件或控制台。
- **stringstream**：既可以从字符串中读取数据，也可以将数据写入字符串，兼具 istringstream 和 ostringstream 的功能。

### stringstream

> stringstream 类兼具 istringstream 和 ostringstream 的功能，既可以从字符串中读取数据，也可以将数据写入字符串。(需要包含\<sstream\>ss头文件)

```c++
#include <iostream>
#include <sstream>
#include <string>
using namespace std;
#define endl '\n'

int main() {
    string lines = "a 25 123456";
    stringstream inps(lines); // inps 是变量名
    int age;
    string name, id;
    inps >> name >> age >> id; // 将字符串中的数据存入定义好的变量中
    cout << "name:" << name << " age:" << age << " id:" << id << endl;
    
    stringstream outs; outs.str().reserve(1024); // 初始化并预留1024字节的空间
    int year = 2022, month = 3, day = 24;
    outs.width(4); outs.fill('0'); outs << year; // 设置下次输入的宽度为4，并用‘0’预先存储，向其中存入年份
    outs.width(2); outs.fill('0'); outs << month;
    outs.width(2); outs.fill('0'); outs << day;
    cout << outs.str() << endl;
    return 0;
}
```

--- 

## 正则表达式-regex

需要包括头文件\<regex>

### std::regex

表示一个正则表达式对象。正则表达式对象可以用来存储和表示一个特定的正则表达式模式。

- **.** ：匹配任意单个字符（换行符除外）。
- **$\left[\;\right]$** ：匹配方括号内的任意一个字符。例如，[abc] 匹配 'a'、'b' 或 'c'。
- **^** ：在方括号内使用时，表示取反。例如，[^abc] 匹配除 'a'、'b'、'c' 之外的任意字符。
- **\d** ：匹配任意数字，等价于 [0-9]。
- **\s** ：匹配任意空白字符，包括空格、制表符、换行符等。
- **\w** ：匹配任意字母、数字或下划线，等价于 [a-zA-Z0-9_]。

**常用量词** 
- **\*** : 匹配前面的模式零次或无数次。
- **\+** : 匹配前面的模式一次或多次。
- **？** ： 匹配前面的模式零次或一次。
- **{n}** : 匹配前面的模式恰好 n 次。
- **{n,}** : 匹配前面的模式 至少 n 次。
- **{n, m}** : 匹配前面的模式至少 n 次至多 m 次。

**常用锚点** 
- **^** : 匹配字符串的开始。
    - ^abc 可以匹配以"abc"开头的字符串。
- **$** : 匹配字符串的结束。
    - abc$ 可以匹配以"abc"结尾的字符串。
- **\b** : 匹配单词的边界。
  - \bcan\b 可以匹配单独的"can"单词。
- **\B** : 匹配非单词边界。
  - \Bcan\B 可以匹配于其他单词内部的"can"。

**分组**
分组用来将模式的匹配结果进行分组，并对每个分组进行单独的处理。用 **( )** 表示。
- (ab)+ 可以匹配 "ab" "abab" "ababab"。
- (a|b) 可以匹配 "a" 或者 "b"。 

```c++
#include <iostream>
#include <regex>
using namespace std;

int main(void){
    string str = "This is a string. 123456789";
    // 创建一个正则表达式对象，pattern为变量名。
    regex pattern("\\d+"); // 匹配一个或多个数字， 括号中也可写作 "[0-9]+"

    return 0;
}
```

### std::regex_match

用于检查整个字符串是否于表达式匹配。

```c++
// 形式 1：仅检查是否匹配
bool regex_match(const char* str, const std::regex& re);
bool regex_match(const std::string& str, const std::regex& re);

// 形式 2：检查匹配并存储匹配结果
template <class BidirIt, class Alloc, class CharT, class Traits>
bool regex_match(
                BidirIt first, 
                BidirIt last,
                std::match_results<BidirIt, Alloc>& m,
                const std::basic_regex<CharT, Traits>& e,
                std::regex_constants::match_flag_type flags = std::regex_constants::match_default
                );
```

例子：

```c++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
    std::string str = "abc123";
    std::regex pattern("abc\\d+");

    if (std::regex_match(str, pattern)) {
        std::cout << "整个字符串匹配正则表达式" << std::endl;
    } else {
        std::cout << "整个字符串不匹配正则表达式" << std::endl;
    }

    return 0;
}
```

### std::regex_search

用于在字符串中查找第一个与正则表达式匹配的子串。

```c++
// 形式 1：仅检查是否存在匹配的子串
bool regex_search(const char* str, const std::regex& re);
bool regex_search(const std::string& str, const std::regex& re);

// 形式 2：查找匹配并存储匹配结果
template <class BidirIt, class Alloc, class CharT, class Traits>
bool regex_search(
                BidirIt first, 
                BidirIt last,
                std::match_results<BidirIt, Alloc>& m,
                const std::basic_regex<CharT, Traits>& e,
                std::regex_constants::match_flag_type flags = std::regex_constants::match_default
                );
```

例子：

```c++
#include <bist/stdc++.h>
using namespace std;

// 普通版
void solve_normal(void){
    string str = "This is a string. 1234567890";
    regex pattern("[0-9]+"); // 匹配一个或多个数字
    smatch matches; // 用于存储匹配的结果。
    if(regex_search(str, matches, pattern)){
        cout << "Found number: " << matches.str() << endl;
    }else{
        cout << "No match found." << endl;
    }
}
// 加强版
void solve_difficult(void){
    string str = "This is a string. 123-456-7890";
    regex pattern("(\\d{3})-(\\d{3})-{\\d{4}}");
    smatch matches;
    if(regex_search(str, matches, pattern)){
        // matches.str(0) 表示返回整个匹配的字符串。
        cout << "Found number: " << matches.str(0) << endl; 
        // matches.str(i) (i > 0) 表示返回第 i 个捕获组的匹配结果。
        for(size_t i = 1; i < matches.size(); i ++){
            cout << "捕获组" << i << ": " << matches.str(i) << endl;
        }   
    }else{
        cout << "Not find." << endl;
    }
}

int main(void){
    cout << "普通版：" << endl;
    solve_normal();

    cout << "加强版: " << endl;
    solve_difficult();

    return 0;
}
```
注：**std::smatch** 对象可以存储多个匹配结果，包括整个匹配的字符串以及各个捕获组的匹配结果。
**smatch 的常用成员函数：**
- **smatch.size()** : 返回匹配结果的数量，包括整个匹配和各个匹配组。
- **smatch.empty()** : 判断匹配结果是否为空。true 表示为空；
- **smatch.prefix()** : 返回匹配结果之前的字符串。
- **smatch.suffix()** : 返回匹配结果之后的字符串。
- **smatch.position()** : 返回匹配结果在原字符串的起始位置。
  - **smatch.position(i)** : (i>0)返回第 i 个捕获组匹配结果在原数组中的起始位置。  
- **smatch.length()** : 返回匹配结果的字符长度。

注：若可没有匹配结果，调用 position 会报错。预先判断是否有匹配结果。

### std::regex_replace

用于替换字符串中与正则表达式匹配的子串。

```c++
// 形式 1：返回替换后的字符串
template <class OutputIt, class BidirIt, class CharT, class Traits, class ST, class SA>
OutputIt regex_replace(
                OutputIt out,
                BidirIt first,
                BidirIt last,
                const std::basic_regex<CharT, Traits>& e,
                const std::basic_string<CharT, ST, SA>& fmt,
                std::regex_constants::match_flag_type flags = std::regex_constants::match_default
                );

// 形式 2：返回替换后的字符串
template <class CharT, class Traits, class ST, class SA, class Fmt>
std::basic_string<CharT, ST, SA> regex_replace(
                const std::basic_string<CharT, ST, SA>& s,
                const std::basic_regex<CharT, Traits>& e,
                Fmt&& fmt,
                std::regex_constants::match_flag_type flags = std::regex_constants::match_default
                );

```


```c++
#include <bits/stdc++.h>;

int main() {
    std::string str = "hello, 123 world";
    std::regex pattern("\\d+");

    std::string result = std::regex_replace(str, pattern, "###");
    std::cout << "替换后的字符串: " << result << std::endl;

    return 0;
}
```

### sregex_iterator

主要用于遍历字符串中所有与给定正则表达式匹配的子串。

```c++
std::sregex_iterator(
                const BidirectionalIterator first, 
                const BidirectionalIterator last,
                const std::basic_regex<CharT, Traits>& re,
                std::regex_constants::match_flag_type flags =  std::regex_constants::match_default
                );
/*
first,last: 表示要搜索的字符串范围，通常是字符串的起始和结束迭代器。
re: 要匹配的正则表达式。
flags: 匹配标志，用于指定匹配的行为，默认为 std::regex_constants::match_default 。
*/
```

例子(不推荐，可能出错，建议用regex_search)：

```c++
#include <iostream>
#include <regex>
#include <string>

int main() {
    std::string text = "The cat sat on the mat. The cat is cute.";
    std::regex pattern("\\b(cat)\\b"); // 匹配整个单词 "cat"

    std::sregex_iterator it(text.begin(), text.end(), pattern);
    std::sregex_iterator end;

    while (it != end) {
        std::smatch match = *it;
        std::cout << "匹配到的子串: " << match.str() << "，起始位置: " << match.position() << std::endl;
        ++it;
    }

    return 0;
}

```



### 应用

#### 替换指定数量个匹配子串

```c++
#include <iostream>
#include <regex>
#include <string>

// 替换原字符串中指定数量的匹配结果
std::string replaceSpecificMatches(const std::string& input, const std::regex& pattern, 
                                   const std::string& replacement, int count) {
    std::string result = input;
    int replacedCount = 0;
    std::sregex_iterator it(result.begin(), result.end(), pattern);
    std::sregex_iterator end;

    while (it != end && replacedCount < count) {
        std::smatch match = *it;
        result.replace(match.position(), match.length(), replacement);
        // 重新创建迭代器，因为字符串已被修改
        it = std::sregex_iterator(result.begin(), result.end(), pattern);
        replacedCount++;
    }
    return result;
}

int main() {
    std::string text = "The cat sat on the mat. The cat is cute.";
    std::regex pattern("\\b(cat)\\b");
    std::string replacement = "dog";
    int replaceCount = 1;

    std::string newText = replaceSpecificMatches(text, pattern, replacement, replaceCount);
    std::cout << "替换 " << replaceCount << " 次后的字符串: " << newText << std::endl;

    return 0;
}    
```

## 前缀函数

定义 **$pi$** 为字符串 **$s$** 的前缀函数。
**$pi$**: $if$ `s[0~i]` 子串有相等的真前缀与真后缀，$then$ `pi[i]` 等于其中最长的一组的长度。
注：“真”代表非空。
例如：$s = abceabcf$
$pi\left[i\right]$ = {0, 0, 0, 0, 1, 2, 3, 0}

## template

朴素：$O(n^3)$

```c++
const int N = 1e5;
int pi[N] = {0}; // s 索引从0开始
for(int i = 1; i < len; i ++){  // 枚举子串结束位置位置，0跳过
    for(int j = i; j > 0; j --){ // 枚举真前后缀区间长度
        if(s.substr(0, j) == s.substr(i - j + 1, j)){
            pi[i] = j;
            break;
        }
    }
}
```

优化一：$O(n^2)$

相邻的前缀函数值最多增加1

```c++
const int N = 1e5;
int pi[N] = {0};
for(int i = 1; i < len; i ++){  // 枚举子串结束位置位置，0跳过
    for(int j = pi[i - 1] + 1; j > 0; j --){
        if(s.substr(0, j) == s.substr(i - j + 1, j)){
            pi[i] = j;
            break;
        }
    }
}
```

优化二：$O(n)$

`s[i + 1] == s[pi[i]]`

```c++
const int N = 1e5;
int pi[N] = {0};
for(int i = 1; i < len; i ++){
    int j = pi[i - 1];
    while(j > 0 && s[i] != s[j]){
        j = pi[j - 1];
    }
    if(s[i] == s[j]){
        j ++;
        pi[i] = j;
    }
}
```


## 字符串匹配-KMP

> KMP算法是一种在任何情况下都能达到 **$O(n + m)$** 复杂度的算法。

### template

```c++
const int N = 1e5 + 10;
int nxt[N];
void getNext(string s){
    // memset(nxt, -1, sizeof nxt); // 不必要
    int m = s.size();
    nxt[0] = -1;
    nxt[1] = 0;
    // i 表示当前要求 nxt 数组值的位置
    // cur 表示当前要和前一个字符比对的下标
    int i = 2, cur = 0;
    while(i < m){
        if(s[i - 1] == s[cur]){
            nxt[i ++] = ++ cur;
        }else if(cur > 0){
            cur = nxt[cur];
        }else{
            nxt[i ++] = 0;
        }
    }
}

int kmp(string s1, string s2){
    /*
    在 s1 中匹配 s2
    */
    int n = s1.size(), m = s2.size();
    int x = 0, y = 0;   // x 为 x1 中当前对比的位置，y 为 x2 中当前对比的位置
    while(x < n && y < m){
        if(s1[x] == s2[y]){
            x ++, y ++;
        }else if(y == 0){
            x ++;
        }else{
            y = nxt[y];
        }
    }
    return y == m ? x - y : -1;
}
```

---

## 字典树（前缀树）

### template(指针)

```c++
struct TrieNode{    // 字典树的节点
    vector<TrieNode*> nxt;  // 子节点
    bool isWord;    // 是否是字符串结尾
    TrieNode():nxt(26, nullptr), isWord(0){}    // 无参构造函数
};

struct TrieTree{    // 字典树
    TrieNode* root; // 根节点
    TrieTree():root(new TrieNode()){}   // 无参构造函数

    void insert(string s){  // 向字典树种添加字符串
        TrieNode* cur = root;   // 初始化光标
        for(char c : s){
            int inx = c - 'a';  // 获取将字母转换为 [0-25] 的数字
            if(!cur->nxt[inx]){ // 如果为空，则向后追加
                cur->nxt[inx] = new TrieNode();
            }
            cur = cur->nxt[inx];    // 光标向后移动
        }
        cur->isWord = true; // 该节点为字符串结尾
    }
    
    bool search(string s){ // 查找是否存在完成字符串 s，要求完整字符串，非前缀
        TrieNode* cur = root;
        for(char c : s){
            int inx = c - 'a';
            if(!cur->nxt[inx]) return false;
            cur = cur->nxt[inx];
        }
        return cur->isWord;
    }
    bool exist(string prefix){  // 查找是否存在前缀字符串 prefix
        TrieNode* cur = root;
        for(char c : prefix){
            int inx = c - 'a';
            if(!cur->nxt[inx]) return false;
            cur = cur->nxt[inx];
        }
        return true;
    }
};
```

### template(数组)

```c++
const int N = 1e5 + 10;

struct TrieTree{
    int tree[N][26], id, isWord[N];
    // tree:字典树    id:通过该编号来记录节点关系    isWord:是否是单词结尾 

    void insert(string s){
        int cur = 0;
        for(char c : s){
            int inx = c - 'a';
            if(!tree[cur][inx]){
                tree[cur][inx] = ++id;
            }
            cur = tree[cur][inx];
        }
        isWord[cur] = 1;
    }

    bool search(string s){
        int cur = 0;
        for(char c : s){
            int inx = c - 'a';
            if(!tree[cur][inx]) return false;
            cur = tree[cur][inx];
        }
        return isWord[cur];
    }
};
```


> [leetcode2416. 字符串的前缀分数和](https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/description/)

```c++
class Solution {
public:
    vector<int> sumPrefixScores(vector<string>& words) {
        struct node{
            node *son[26]{};
            // vector<node*> son{26, nullptr};
            int score = 0;
        };
        node *root = new node();
        for(auto &word : words){
            auto cur = root;
            for(char ch : word){
                ch -= 'a';
                if(!cur->son[ch]){
                    cur->son[ch] = new node();
                }
                cur = cur->son[ch];
                cur->score ++;
            }
        }
        int n = words.size();
        vector<int> ans(n, 0);
        for(int i = 0; i < n; i ++){
            auto cur = root;
            for(auto ch : words[i]){
                cur = cur->son[ch - 'a'];
                ans[i] += cur->score;
            }
        }
        return ans;
    }
};
```

---

## 字符串最小表示

```c++
int minRepresentation(string s){
    int n = s.size();
    s += s; // 将字符串拼接成两倍长，方便处理循环位移
    int i = 0, j = 1, k = 0; // i 和 j 是两个起始位置，k 是当前比较的字符数
    while (i < n && j < n && k < n) {
        if (s[i + k] == s[j + k]) {
            k++; // 当前字符相等，继续比较下一个字符
            continue;
        }
        if (s[i + k] > s[j + k]) {
            i = i + k + 1; // i 的字典序更大，跳过当前比较
        } else {                
            j = j + k + 1; // j 的字典序更大，跳过当前比较
        }
        if (i == j) i ++; // 避免 i 和 j 重合
        k = 0; // 重置比较的字符数
        
    }
    return min(i, j); // 返回字典序最小的起始位置
}
```

